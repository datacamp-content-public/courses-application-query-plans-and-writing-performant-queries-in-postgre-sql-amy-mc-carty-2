---
title: Insert title here
key: 36d87278623bdf08a11d40e81fcb06b0

---
## Creating and Using Partitions

```yaml
type: "TitleSlide"
key: "d0ed72f79e"
```

`@lower_third`

name: Amy McCarty
title: Data Analyst


`@script`
We just learned about different database storage techniques. Now let’s drive into some of the optimization techniques used with row storage, starting with partitions.


---
## What is Partitioning?

```yaml
type: "FullSlide"
key: "ceb9b0e5db"
```

`@part1`
_**Partitioning is splitting one large (parent) table into smaller (children) tables.**_



**You will Learn the Basics of Partitioning
**
- Why
- Where
- How


`@script`
In this course, you will learn about why partitioning is used and on which type of tables you will find it. We will cover both how to implement in a database and how to access in an analytic query.


---
## Why and Where to Use Partitions

```yaml
type: "FullSlide"
key: "c19771dbec"
```

`@part1`
**Why DBAs Use Partitions**
- Improve bulk load and delete performance
- Grants storage flexibility
- Improves security

**Why Analysts Use Partitions**
- Query Performance

**What Tables are best suited for Partitioning?**
- Large Tables
- Commonly used filtering metric


`@script`
Database administrators may opt to utilize partitions for a variety of reasons.
- For instance, adding or deleting a partition can speed bulk loads and deletes that would otherwise operate on an entire table
- Children tables can be stored on different servers and seldom used partitions can be moved to cheaper, slower storage options.
- Separating out sensitive data or data from different customers can help improve security measures.

Analysts and data scientists can then utilize these partitions to improve their query performance. Referencing a partition allows the query to search a subset of data, speeding the process.

It is important to note partitioning requires resources so is not used on every table. Large tables with a common filter condition, such as a date or location common, provide good use cases.


---
## Partitioning Terminology

```yaml
type: "FullSlide"
key: "393efa4a83"
```

`@part1`
**Declarative Partitioning**
- Partitioned Table
- Partitions
- Partition Key
- Partition Bounds
- Partition Method


`@script`
Declarative partitioning is the native approach in PostgreSQL

The PARTITIONED TABLE is the parent table and it is divided into individual pieces, the PARTITIONS. The PARTITION KEY, the relevant column or expressions, create the divisions and define the PARTITION BOUNDS. The divisions can be created with different PARTITION METHODS, such as using an all inclusive list to define the KEY.


---
## Setting up a Partition

```yaml
type: "FullSlide"
key: "809c9787ca"
```

`@part1`
1. Create the partitioned, or parent, table

2. Create the partitions, or children, tables

3. Create an index

4. Configure postgresql.conf 

5. Perform Maintenance


`@script`
Using PostgreSQL 10 or later, setting up a partition follows these 5 main steps.
1) Create the partitioned, or parent, table
2) Create the partitions, or children, tables. 
- Choose the partitioning method
- Create optional sub-partitions
3) Create an index
4) Configure postgresql.conf 
5) Perform Maintenance


---
## Setting up a Partition: Partitioned Table

```yaml
type: "FullCodeSlide"
key: "c2ea231143"
```

`@part1`
**Partitioned Table**
```sql
CREATE TABLE customer_orders (
	customer_id	int not null,
	order_id	int not null,
	order_date	date not null,
	order_year	int,
	product_qty	int
) PARTITION BY RANGE (order_date);
```


`@script`
The partitioned table is created as a normal table, with the PARTITION BY condition added. The children tables will be created using ranges from the order_date column.


---
## Setting up a Partition: Partitions

```yaml
type: "FullSlide"
key: "96e87d5431"
```

`@part1`
**Range 		
) PARTITION BY RANGE (order_date);**{{1}}
```sql
CREATE TABLE co_2017 PARTITION OF customer_orders
	FOR VALUES FROM (‘2017-01-01’) TO (‘2018-01-01’)
	TABLESPACE oldserver;

CREATE TABLE co_2018 PARTITION OF customer_orders
	FOR VALUES FROM (‘2018-01-01’) TO (‘2019-01-01’);
```{{1}}
**List 	
) PARTITION BY LIST (order_year);**{{2}}
```sql
CREATE TABLE co_2018 PARTITION OF customer_orders
	FOR VALUES IN (2018);
```{{2}}


`@script`
Using range as the partition method, two children tables are created off the order date. The start and end values are specified. 
If overlapping constraints are created in different children tables, the affected data insert will fail.
Also note that the first create table specifies the tablespace, demonstrating how children tables can be stored on unique servers.

The second examples shows a child table if the partition method is list instead of range.


---
## Setting up a Partition: Indexes and Configurations

```yaml
type: "FullSlide"
key: "ed1fd90883"
```

`@part1`
**Indexes**
```sql
Create INDEX ON co_2018 (order_date);
Create INDEX ON co_2017 (order_date);
```
**Configure constraint_exclusion in postgresql.conf**
- use the recommended partition setting


`@script`
Indexes should be created on the partition key and must must be created on each child table, as shown in the examples here.

We will discuss more about the advantages and uses of indexes in a later lesson.

Finally, ensure that constraint_exclusion in postgresql.conf uses the default partition setting. This will allow the query planner, which we we learn more about later, to only look for constraints on partitioned tables.


---
## Setting up a Partition: Configure postgresql.conf

```yaml
type: "FullSlide"
key: "a750eee043"
```

`@part1`
ensure constraint_exclusion configuration parameter is not disabled
The default (and recommended) setting of constraint_exclusion is actually neither on nor off, but an intermediate setting called partition, which causes the technique to be applied only to queries that are likely to be working on partitioned tables. The on setting causes the planner to examine CHECKconstraints in all queries, even simple ones that are unlikely to benefit.


`@script`



---
## Final Slide

```yaml
type: "FinalSlide"
key: "7603756d0d"
```

`@script`


